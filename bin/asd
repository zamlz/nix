#!/usr/bin/env sh

# [a]mlesh's [s]cript for [d]otfiles
# IDK, I had to think of an acronym for asd

. $HOME/lib/shell/logging && eval "$(get_logger $0)"

# A simple script that manages dotfiles repo and beyond
. $HOME/lib/repos
. $HOME/lib/shell/colorenv

help_prompt() {
    echo "Usage: $(basename $0) [CMD]"
    echo "    Commands:"
    echo "      - setup: Runs dotfiles setup files"
    echo "      - info: Show shell variable info for primary repos"
    echo "      - status: Show git status for primary repos (default command)"
    echo "      - clone: Clone the primary repos"
    echo "      - fetch: Fetch latest over all primary repos"
    echo "      - pull: Pull latest over all primary repos"
    echo "      - git: Run any git command over all primary repos"
    echo "      - help: Show this help dialogue"
}

# Configure dotfiles in the current directory
# (Used when installing new distros)
setup_dots() {
    HOME="${1:-$HOME}"

    # setup phase:
    # - We source them instead of running them so that they can
    #   get access to the ${HOME} variable defined above.
    . $HOME/etc/git/setup.sh
    . $HOME/etc/gnupg/setup.sh
    . $HOME/etc/picom/setup.sh
    . $HOME/etc/polybar/setup.sh
    . $HOME/etc/qutebrowser/setup.sh
    . $HOME/etc/rofi/setup.sh
    . $HOME/etc/ssh/setup.sh
    . $HOME/etc/taskwarrior/setup.sh
    . $HOME/etc/vim/setup.sh
    . $HOME/etc/xorg/setup.sh
    . $HOME/etc/zsh/setup.sh

    echo "Setup scripts complete :)"
}

clone_repo() {
    COLOR=$1 && shift && REPO_DIR=$1 && shift && REPO_URL=$1
    echo -e "[${Bold}REPOSITORY: ${COLOR}${REPO_DIR}${Rst}]"
    if [ ! -d "$REPO_DIR" ] && [ -n "$REPO_URL" ]; then
        echo "Cloning ${REPO_URL} to ${REPO_DIR}"
        git clone ${REPO_URL} ${REPO_DIR}
    elif [ -d "$REPO_DIR" ]; then
        echo "Repo directory already exists!"
    fi
    # If all else fails, it means that the URL has not be set.
    # we want to quietly fail here in that case.
}

clone_repos_over_all() {
    clone_repo ${Red} ${BOOKMARKS_DIR} ${BOOKMARKS_GIT_REPO}
    clone_repo ${Red} ${LEDGER_DIR} ${LEDGER_GIT_REPO}
    #clone_repo ${Red} ${PAPERS_DIR} ${PAPERS_GIT_REPO}
    clone_repo ${Red} ${PASSWORD_STORE_DIR} ${PASSWORD_STORE_GIT_REPO}
    clone_repo ${Red} ${WEBSITE_DIR} ${WEBSITE_GIT_REPO}
    clone_repo ${Red} ${COLORSCRIPT_DIR} ${COLORSCRIPT_GIT_REPO}
}

# Run a git command (${2-}) in a given repo (${1})
run_git() {
    COLOR=$1 && shift && REPO_DIR=$1 && shift && GIT_ARGS=$@;
    if [ -d "$REPO_DIR" ] ; then
        echo -e "[${Bold}REPOSITORY: ${COLOR}${REPO_DIR}${Rst}]"
        echo "git -C $REPO_DIR $GIT_ARGS"
        git -C $REPO_DIR $GIT_ARGS
    fi
}

run_git_over_all() {
    COLOR=$1 && shift && GIT_ARGS=$@;
    run_git ${COLOR} ${DOTFILES_DIR} $GIT_ARGS;
    run_git ${COLOR} ${BOOKMARKS_DIR} $GIT_ARGS;
    run_git ${COLOR} ${LEDGER_DIR} $GIT_ARGS;
    run_git ${COLOR} ${PAPERS_DIR} $GIT_ARGS;
    run_git ${COLOR} ${PASSWORD_STORE_DIR} $GIT_ARGS;
    run_git ${COLOR} ${WEBSITE_DIR} $GIT_ARGS;
}

sync_packages() {
    HOME="${1:-$HOME}"

    if [ -z "$(grep 'Arch Linux' /etc/os-release)" ]; then
        echo -e "${Red}ERROR:${Rst} This doesn't appear to be a Arch Linux machine!?"
        exit 1
    fi

    package_list=$(cat $(find $HOME/etc/ -type f -name packages.txt) \
        | awk '!/^ *#/ && NF' \
        | sort | uniq)

    echo -e "[${Blue} RUNNING FULL SYSTEM UPGRADE ${Rst}]"
    sudo pacman -Syu
    echo -e "[${Green} SYNCING LOCAL PACKAGE LIST ${Rst}]"
    sudo pacman -S --needed ${package_list}
}

if [[ -z "$@" ]]; then
    CMD="" && ARGS=""
else
    CMD=$1 && shift && ARGS=$@
fi

case "$CMD" in
    "clone")        clone_repos_over_all ;;
    "fetch")        run_git_over_all ${Yellow} "fetch --all" ;;
    "pull")         run_git_over_all ${Purple} "pull" ;;
    "git")          run_git_over_all ${Green} $ARGS ;;
    "info")         cat $HOME/lib/repos ;;
    "setup")        setup_dots $ARGS ;;
    "sync")         sync_packages $ARGS ;;
    "status")       run_git_over_all ${Blue} "status --short" ;;
    "")             run_git_over_all ${Blue} "status --short" ;;
    "-h")           help_prompt ;;
    "help")         help_prompt ;;
    *)              echo "Unknown Command: $CMD $ARGS" && help_prompt ;;
esac
